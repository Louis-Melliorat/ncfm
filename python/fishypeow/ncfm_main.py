# Get modules
import os
import glob
import cv2
import datetime
import time
#import warnings4

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
#from matplotlib import pyplot as plt

# Input data files are available in the "../input/" directory.
# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory

from subprocess import check_output
print(check_output(["ls", "../../data"]).decode("utf8"))

# Any results you write to the current directory are saved as output.

# Machine Larning Stuff
from sklearn.cross_validation import KFold
from keras.models import Sequential
from keras.layers.core import Dense, Dropout, Flatten
from keras.layers.convolutional import Convolution2D, MaxPooling2D, ZeroPadding2D, AveragePooling2D
from keras.optimizers import SGD, Adagrad
from keras.callbacks import EarlyStopping, CSVLogger, ReduceLROnPlateau
from sklearn.metrics import log_loss, classification_report
from keras import __version__ as keras_version
from keras.preprocessing.image import ImageDataGenerator

# application packaging
from ncfm_model import create_model, evaluate_model, create_submission
from ncfm_img_proc import read_and_normalize_train_data, read_and_normalize_test_data


def dict_to_list(d):
    ret = []
    for i in d.items():
        ret.append(i[1])
    return ret


def merge_several_folds_mean(data, nfolds):
    a = np.array(data[0])
    for i in range(1, nfolds):
        a += np.array(data[i])
    a /= nfolds
    return a.tolist()


def run_cross_validation_create_models(nfolds=10, data_augmentation=True, img_size=(48,48)):
    # input image dimensions
    batch_size = 24
    nb_epoch = 60
    random_state = 51
    first_rl = 96
    lr=1e-2

    train_data, train_target, train_id = read_and_normalize_train_data(img_size)

    yfull_train = dict()
    kf = KFold(len(train_id), n_folds=nfolds, shuffle=True, random_state=random_state)
    num_fold = 0
    sum_score = 0
    models = []
    for train_index, test_index in kf:
        start_time_model_fitting = time.time()
        model = create_model(learning_rate=lr, dec=1e-6, moment=0.898, img_size=img_size)
        X_train = train_data[train_index]
        Y_train = train_target[train_index]
        X_valid = train_data[test_index]
        Y_valid = train_target[test_index]

        num_fold += 1
        print('Start KFold number {} from {}'.format(num_fold, nfolds))
        print('Split train: ', len(X_train), len(Y_train))
        print('Split valid: ', len(X_valid), len(Y_valid))

        callbacks = [
            EarlyStopping(monitor='val_loss', patience=3, verbose=1),
            ReduceLROnPlateau(monitor='val_loss', factor=0.85,
                             patience=2, min_lr=0.001),
            CSVLogger('./logs/training_{}.log'.format(datetime.datetime.now().strftime("%Y-%m-%d-%H-%M")), separator=';', append=True),
        ]
        if (data_augmentation):
            print('Using real-time data augmentation.')
            datagen = ImageDataGenerator(
                        featurewise_center=False,  # set input mean to 0 over the dataset
                        samplewise_center=False,  # set each sample mean to 0
                        featurewise_std_normalization=False,  # divide inputs by std of the dataset
                        samplewise_std_normalization=False,  # divide each input by its std
                        zca_whitening=False,  # apply ZCA whitening
                        rotation_range=10,  # randomly rotate images in the range (degrees, 0 to 180)
                        width_shift_range=0.02,  # randomly shift images horizontally (fraction of total width)
                        height_shift_range=0.02,  # randomly shift images vertically (fraction of total height)
                        horizontal_flip=True,  # randomly flip images
                        vertical_flip=True)  # randomly flip images
            # Compute quantities required for featurewise normalization
            # (std, mean, and principal components if ZCA whitening is applied).
            datagen.fit(X_train)

            # Fit the model on the batches generated by datagen.flow().
            model.fit_generator(datagen.flow(X_train, Y_train,
                                batch_size=batch_size),
                                samples_per_epoch=X_train.shape[0],
                                nb_epoch=nb_epoch,
                                validation_data=(X_valid, Y_valid))
        else:
            print('Not using real-time data augmentation.')
            model.fit(X_train,
                      Y_train,
                      batch_size=batch_size,
                      nb_epoch=nb_epoch,
                      shuffle=True,
                      verbose=1,
                      validation_data=(X_valid, Y_valid),
                      callbacks=callbacks)

        predictions_valid = model.predict(X_valid.astype('float32'), batch_size=batch_size, verbose=2)

        score = evaluate_model(Y_valid, predictions_valid)
        sum_score += score*len(test_index)

        print('Compute and fit model : {} seconds'.format(round(time.time() - start_time_model_fitting, 2)))

        # Store valid predictions
        for i in range(len(test_index)):
            yfull_train[test_index[i]] = predictions_valid[i]

        models.append(model)

    score = sum_score/len(train_data)
    print("Log_loss train independent avg: ", score)

    info_string = 'loss_' + str(score) + '_folds_' + str(nfolds) + '_ep_' + str(nb_epoch) + '_fl_' + str(first_rl)
    if (data_augmentation):
            info_string+='_data_aug_'
    return info_string, models


def run_cross_validation_process_test(info_string, models, img_size):
    batch_size = 24
    num_fold = 0
    yfull_test = []
    test_id = []
    nfolds = len(models)

    for i in range(nfolds):
        model = models[i]
        num_fold += 1
        print('Start KFold number {} from {}'.format(num_fold, nfolds))
        test_data, test_id = read_and_normalize_test_data(img_size)
        test_prediction = model.predict(test_data, batch_size=batch_size, verbose=2)
        yfull_test.append(test_prediction)

    test_res = merge_several_folds_mean(yfull_test, nfolds)
    info_string = 'loss_' + info_string \
                + '_folds_' + str(nfolds)
    create_submission(test_res, test_id, info_string)


if __name__ == '__main__':
    #set seed
    np.random.seed(1234)
    print('Keras version: {}'.format(keras_version))
    num_folds = 8
    data_augmentation = True
    img_size=(96,96)
    info_string, models = run_cross_validation_create_models(num_folds, data_augmentation, img_size)
    run_cross_validation_process_test(info_string, models, img_size)
